'use strict';

var _electron = require('electron');

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _electronCompile = require('electron-compile');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _statSyncNoException(fd) {
  let result = null;
  try {
    result = _fs2.default.statSync(fd);
  } catch (e) {}

  return result;
}

function findPackageJson(initScript) {
  if (initScript === '/' || initScript.match(/^[A-Za-z]:$/)) {
    throw new Error("Can't find package.json");
  }

  // Walk up the parent directories until we find package.json. Make sure that
  // we're not actually stumbling upon a parent npm package
  let ret = _path2.default.join(initScript, 'package.json');
  if (_statSyncNoException(ret) && !_path2.default.resolve(_path2.default.dirname(ret), '..').match(/[\\\/]node_modules$/i)) {
    return ret;
  }

  return findPackageJson(_path2.default.dirname(initScript));
}

/**
 * Some debugger environment reconstruct process argument and inject args ignoring original order,
 * extract to find out right path for init script.
 *
 */
function getInitScriptPath() {
  const rawArgv = process.argv.filter(x => x.indexOf(`--inspect=`) === -1 && x.indexOf(`--debug-brk`))[2];
  return _path2.default.resolve(rawArgv);
}

function main() {
  const initScript = getInitScriptPath();
  const packageJson = findPackageJson(initScript);
  const appPath = _path2.default.dirname(packageJson);
  const packageJsonData = JSON.parse(_fs2.default.readFileSync(packageJson, 'utf8'));

  _electron.app.setName(packageJsonData.productName || packageJsonData.name);
  _electron.app.setVersion(packageJsonData.version);
  _electron.app.setAppPath(appPath);

  // Reconstitute the original arguments
  const args = process.argv.slice(2);
  process.argv = [process.argv[0]].concat(args);

  //passthrough electron-compile command args if it's specified
  const parsedArgs = require('yargs').alias('c', 'cachedir').alias('s', 'sourcemapdir').argv;
  (0, _electronCompile.init)(_path2.default.dirname(packageJson), initScript, null, parsedArgs.c || null, parsedArgs.s || null);
}

main();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lczYtaW5pdC5qcyJdLCJuYW1lcyI6WyJfc3RhdFN5bmNOb0V4Y2VwdGlvbiIsImZkIiwicmVzdWx0IiwiZnMiLCJzdGF0U3luYyIsImUiLCJmaW5kUGFja2FnZUpzb24iLCJpbml0U2NyaXB0IiwibWF0Y2giLCJFcnJvciIsInJldCIsInBhdGgiLCJqb2luIiwicmVzb2x2ZSIsImRpcm5hbWUiLCJnZXRJbml0U2NyaXB0UGF0aCIsInJhd0FyZ3YiLCJwcm9jZXNzIiwiYXJndiIsImZpbHRlciIsIngiLCJpbmRleE9mIiwibWFpbiIsInBhY2thZ2VKc29uIiwiYXBwUGF0aCIsInBhY2thZ2VKc29uRGF0YSIsIkpTT04iLCJwYXJzZSIsInJlYWRGaWxlU3luYyIsImFwcCIsInNldE5hbWUiLCJwcm9kdWN0TmFtZSIsIm5hbWUiLCJzZXRWZXJzaW9uIiwidmVyc2lvbiIsInNldEFwcFBhdGgiLCJhcmdzIiwic2xpY2UiLCJjb25jYXQiLCJwYXJzZWRBcmdzIiwicmVxdWlyZSIsImFsaWFzIiwiYyIsInMiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUEsU0FBU0Esb0JBQVQsQ0FBOEJDLEVBQTlCLEVBQWtDO0FBQ2hDLE1BQUlDLFNBQVMsSUFBYjtBQUNBLE1BQUk7QUFDRkEsYUFBU0MsYUFBR0MsUUFBSCxDQUFZSCxFQUFaLENBQVQ7QUFDRCxHQUZELENBRUUsT0FBTUksQ0FBTixFQUFTLENBQ1Y7O0FBRUQsU0FBT0gsTUFBUDtBQUNEOztBQUVELFNBQVNJLGVBQVQsQ0FBeUJDLFVBQXpCLEVBQXFDO0FBQ25DLE1BQUlBLGVBQWUsR0FBZixJQUFzQkEsV0FBV0MsS0FBWCxDQUFpQixhQUFqQixDQUExQixFQUEyRDtBQUN6RCxVQUFNLElBQUlDLEtBQUosQ0FBVSx5QkFBVixDQUFOO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQUlDLE1BQU1DLGVBQUtDLElBQUwsQ0FBVUwsVUFBVixFQUFzQixjQUF0QixDQUFWO0FBQ0EsTUFBSVAscUJBQXFCVSxHQUFyQixLQUE2QixDQUFDQyxlQUFLRSxPQUFMLENBQWFGLGVBQUtHLE9BQUwsQ0FBYUosR0FBYixDQUFiLEVBQWdDLElBQWhDLEVBQXNDRixLQUF0QyxDQUE0QyxzQkFBNUMsQ0FBbEMsRUFBdUc7QUFDckcsV0FBT0UsR0FBUDtBQUNEOztBQUVELFNBQU9KLGdCQUFnQkssZUFBS0csT0FBTCxDQUFhUCxVQUFiLENBQWhCLENBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQSxTQUFTUSxpQkFBVCxHQUE2QjtBQUMzQixRQUFNQyxVQUFVQyxRQUFRQyxJQUFSLENBQWFDLE1BQWIsQ0FBcUJDLENBQUQsSUFBT0EsRUFBRUMsT0FBRixDQUFXLFlBQVgsTUFBNEIsQ0FBQyxDQUE3QixJQUFrQ0QsRUFBRUMsT0FBRixDQUFXLGFBQVgsQ0FBN0QsRUFBdUYsQ0FBdkYsQ0FBaEI7QUFDQSxTQUFPVixlQUFLRSxPQUFMLENBQWFHLE9BQWIsQ0FBUDtBQUNEOztBQUVELFNBQVNNLElBQVQsR0FBZ0I7QUFDZCxRQUFNZixhQUFhUSxtQkFBbkI7QUFDQSxRQUFNUSxjQUFjakIsZ0JBQWdCQyxVQUFoQixDQUFwQjtBQUNBLFFBQU1pQixVQUFVYixlQUFLRyxPQUFMLENBQWFTLFdBQWIsQ0FBaEI7QUFDQSxRQUFNRSxrQkFBa0JDLEtBQUtDLEtBQUwsQ0FBV3hCLGFBQUd5QixZQUFILENBQWdCTCxXQUFoQixFQUE2QixNQUE3QixDQUFYLENBQXhCOztBQUVBTSxnQkFBSUMsT0FBSixDQUFZTCxnQkFBZ0JNLFdBQWhCLElBQStCTixnQkFBZ0JPLElBQTNEO0FBQ0FILGdCQUFJSSxVQUFKLENBQWVSLGdCQUFnQlMsT0FBL0I7QUFDQUwsZ0JBQUlNLFVBQUosQ0FBZVgsT0FBZjs7QUFFQTtBQUNBLFFBQU1ZLE9BQU9uQixRQUFRQyxJQUFSLENBQWFtQixLQUFiLENBQW1CLENBQW5CLENBQWI7QUFDQXBCLFVBQVFDLElBQVIsR0FBZSxDQUFDRCxRQUFRQyxJQUFSLENBQWEsQ0FBYixDQUFELEVBQWtCb0IsTUFBbEIsQ0FBeUJGLElBQXpCLENBQWY7O0FBRUE7QUFDQSxRQUFNRyxhQUFhQyxRQUFRLE9BQVIsRUFBaUJDLEtBQWpCLENBQXVCLEdBQXZCLEVBQTRCLFVBQTVCLEVBQXdDQSxLQUF4QyxDQUE4QyxHQUE5QyxFQUFtRCxjQUFuRCxFQUFtRXZCLElBQXRGO0FBQ0EsNkJBQUtQLGVBQUtHLE9BQUwsQ0FBYVMsV0FBYixDQUFMLEVBQWdDaEIsVUFBaEMsRUFBNEMsSUFBNUMsRUFBa0RnQyxXQUFXRyxDQUFYLElBQWdCLElBQWxFLEVBQXdFSCxXQUFXSSxDQUFYLElBQWdCLElBQXhGO0FBQ0Q7O0FBRURyQiIsImZpbGUiOiJlczYtaW5pdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcCB9IGZyb20gJ2VsZWN0cm9uJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7aW5pdH0gZnJvbSAnZWxlY3Ryb24tY29tcGlsZSc7XG5cbmZ1bmN0aW9uIF9zdGF0U3luY05vRXhjZXB0aW9uKGZkKSB7XG4gIGxldCByZXN1bHQgPSBudWxsO1xuICB0cnkge1xuICAgIHJlc3VsdCA9IGZzLnN0YXRTeW5jKGZkKTtcbiAgfSBjYXRjaChlKSB7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaW5kUGFja2FnZUpzb24oaW5pdFNjcmlwdCkge1xuICBpZiAoaW5pdFNjcmlwdCA9PT0gJy8nIHx8IGluaXRTY3JpcHQubWF0Y2goL15bQS1aYS16XTokLykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIHBhY2thZ2UuanNvblwiKTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHBhcmVudCBkaXJlY3RvcmllcyB1bnRpbCB3ZSBmaW5kIHBhY2thZ2UuanNvbi4gTWFrZSBzdXJlIHRoYXRcbiAgLy8gd2UncmUgbm90IGFjdHVhbGx5IHN0dW1ibGluZyB1cG9uIGEgcGFyZW50IG5wbSBwYWNrYWdlXG4gIGxldCByZXQgPSBwYXRoLmpvaW4oaW5pdFNjcmlwdCwgJ3BhY2thZ2UuanNvbicpO1xuICBpZiAoX3N0YXRTeW5jTm9FeGNlcHRpb24ocmV0KSAmJiAhcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShyZXQpLCAnLi4nKS5tYXRjaCgvW1xcXFxcXC9dbm9kZV9tb2R1bGVzJC9pKSkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICByZXR1cm4gZmluZFBhY2thZ2VKc29uKHBhdGguZGlybmFtZShpbml0U2NyaXB0KSk7XG59XG5cbi8qKlxuICogU29tZSBkZWJ1Z2dlciBlbnZpcm9ubWVudCByZWNvbnN0cnVjdCBwcm9jZXNzIGFyZ3VtZW50IGFuZCBpbmplY3QgYXJncyBpZ25vcmluZyBvcmlnaW5hbCBvcmRlcixcbiAqIGV4dHJhY3QgdG8gZmluZCBvdXQgcmlnaHQgcGF0aCBmb3IgaW5pdCBzY3JpcHQuXG4gKlxuICovXG5mdW5jdGlvbiBnZXRJbml0U2NyaXB0UGF0aCgpIHtcbiAgY29uc3QgcmF3QXJndiA9IHByb2Nlc3MuYXJndi5maWx0ZXIoKHgpID0+IHguaW5kZXhPZihgLS1pbnNwZWN0PWApID09PSAtMSAmJiB4LmluZGV4T2YoYC0tZGVidWctYnJrYCkpWzJdO1xuICByZXR1cm4gcGF0aC5yZXNvbHZlKHJhd0FyZ3YpO1xufVxuXG5mdW5jdGlvbiBtYWluKCkge1xuICBjb25zdCBpbml0U2NyaXB0ID0gZ2V0SW5pdFNjcmlwdFBhdGgoKTtcbiAgY29uc3QgcGFja2FnZUpzb24gPSBmaW5kUGFja2FnZUpzb24oaW5pdFNjcmlwdCk7XG4gIGNvbnN0IGFwcFBhdGggPSBwYXRoLmRpcm5hbWUocGFja2FnZUpzb24pO1xuICBjb25zdCBwYWNrYWdlSnNvbkRhdGEgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYWNrYWdlSnNvbiwgJ3V0ZjgnKSk7XG5cbiAgYXBwLnNldE5hbWUocGFja2FnZUpzb25EYXRhLnByb2R1Y3ROYW1lIHx8IHBhY2thZ2VKc29uRGF0YS5uYW1lKTtcbiAgYXBwLnNldFZlcnNpb24ocGFja2FnZUpzb25EYXRhLnZlcnNpb24pO1xuICBhcHAuc2V0QXBwUGF0aChhcHBQYXRoKTtcblxuICAvLyBSZWNvbnN0aXR1dGUgdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuICBjb25zdCBhcmdzID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xuICBwcm9jZXNzLmFyZ3YgPSBbcHJvY2Vzcy5hcmd2WzBdXS5jb25jYXQoYXJncyk7XG5cbiAgLy9wYXNzdGhyb3VnaCBlbGVjdHJvbi1jb21waWxlIGNvbW1hbmQgYXJncyBpZiBpdCdzIHNwZWNpZmllZFxuICBjb25zdCBwYXJzZWRBcmdzID0gcmVxdWlyZSgneWFyZ3MnKS5hbGlhcygnYycsICdjYWNoZWRpcicpLmFsaWFzKCdzJywgJ3NvdXJjZW1hcGRpcicpLmFyZ3Y7XG4gIGluaXQocGF0aC5kaXJuYW1lKHBhY2thZ2VKc29uKSwgaW5pdFNjcmlwdCwgbnVsbCwgcGFyc2VkQXJncy5jIHx8IG51bGwsIHBhcnNlZEFyZ3MucyB8fCBudWxsKTtcbn1cblxubWFpbigpXG4iXX0=